@using Microsoft.Extensions.Logging;
@using Microsoft.JSInterop;
@using ThreeNET.Objects.Geometry;
@using ThreeNET.Objects.Meshes.Materials;
@inject ThreeJSInterop Three
@inject IJSRuntime JS
@inject ILogger<ThreeView> Logger
@implements IAsyncDisposable
<h3>ThreeView</h3>
<div @ref=threeElement>
	test
</div>
@code {
	private ThreePerspectiveCamera? Camera { get; set; }
	private ThreeScene? Scene { get; set; }
	private ThreeWebGLRenderer? Renderer { get; set; }
	private ThreeMesh? BoxMesh { get; set; }
	private bool Disposed { get; set; }
	private SemaphoreSlim semaphoreSlim = new(1, 1);
	private ElementReference threeElement;

	[Parameter]
	public Func<TimeSpan, Task>? Update { get; set; }
	[Parameter]
	public Func<Task>? Startup { get; set; }
	[Parameter]
	public Func<Task>? Shutdown { get; set; }

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if (firstRender)
		{
			Scene = await Three.Create<ThreeScene>();
			Camera = await Three.Create<ThreePerspectiveCamera>(75, 1, 0.1, 1000);
			Renderer = await Three.Create<ThreeWebGLRenderer>();
			await Renderer.SetSize(400, 400);
			await Renderer.PlaceInDOM(threeElement);

			ThreeMeshMaterialOptions options = new()
				{
					Color = 0xfcc43e,
				};


			var box = await Three.Create<ThreeBoxGeometry>(1, 1, 1);
			var material = await Three.Create<ThreeMeshBasicMaterial>(new
			{
				color = options.HexColorString
			});
			BoxMesh = await Three.Create<ThreeMesh>(box.ObjectReference, material.ObjectReference);
			await Scene.Add(BoxMesh);
			await Camera.SetPosition(z: 5);
			lastAnimateTime = DateTime.UtcNow;
			await (Startup?.Invoke()).GetAwaiterOrDefault();

			await Three.RequestAnimationFrame(Animate);
		}
	}

	private DateTime lastAnimateTime;
	public async Task Animate()
	{
		await semaphoreSlim.WaitAsync();
		try
		{
			if (!Disposed)
			{
				await Renderer!.Render(Scene!, Camera!);
				await (Update?.Invoke(DateTime.UtcNow - lastAnimateTime)).GetAwaiterOrDefault();
				lastAnimateTime = DateTime.UtcNow;
				await Three.RequestAnimationFrame(Animate);
			}
		} catch (Exception ex)
		{
			Logger.LogError(ex, null);
		} finally
		{
			semaphoreSlim.Release();
		}
	}

	public async ValueTask DisposeAsync()
	{
		await semaphoreSlim.WaitAsync();
		try
		{
			await (Shutdown?.Invoke()).GetAwaiterOrDefault();
			Disposed = true;
			await Camera.DisposeOrDefaultAsync();
			await Scene.DisposeOrDefaultAsync();
			await Scene.DisposeOrDefaultAsync();
			await BoxMesh.DisposeOrDefaultAsync();
		} finally
		{
			semaphoreSlim.Release();
		}
	}
}
